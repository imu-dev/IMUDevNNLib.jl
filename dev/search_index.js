var documenterSearchIndex = {"docs":
[{"location":"pages/other/#Other","page":"Other","title":"Other","text":"","category":"section"},{"location":"pages/other/","page":"Other","title":"Other","text":"Some additional tools include:","category":"page"},{"location":"pages/other/","page":"Other","title":"Other","text":"skipfirstobs\nselectfirstobs\neachslicelastdim","category":"page"},{"location":"pages/other/#IMUDevNNLib.skipfirstobs","page":"Other","title":"IMUDevNNLib.skipfirstobs","text":"skipfirstobs(x::AbstractArray)\n\nGiven an array x representing a time series, with the last dimension corresponding to time, return a new array with the first observation removed.\n\n\n\n\n\n","category":"function"},{"location":"pages/other/#IMUDevNNLib.selectfirstobs","page":"Other","title":"IMUDevNNLib.selectfirstobs","text":"selectfirstobs(x::AbstractArray)\n\nGiven an array x representing a time series, with the last dimension corresponding to time, return a new array with only the first observation.\n\n\n\n\n\n","category":"function"},{"location":"pages/other/#IMUDevNNLib.eachslicelastdim","page":"Other","title":"IMUDevNNLib.eachslicelastdim","text":"eachslicelastdim(m::AbstractArray{<:Any,N}) where {N}\n\nReturn an iterator over the last dimension of m.\n\n\n\n\n\n","category":"function"},{"location":"#IMUDevNNLib.jl","page":"Home","title":"IMUDevNNLib.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Toolbox designed to support workflows involving Neural Networks. In particular, it implements some of the key processes encountered when specializing to IMU data that are not covered by NNlib.","category":"page"},{"location":"pages/batched_operations/#Batched-Operations","page":"Batched Operations","title":"Batched Operations","text":"","category":"section"},{"location":"pages/batched_operations/","page":"Batched Operations","title":"Batched Operations","text":"NNlib implements a useful spectrum of operations designed to work with batches. At the moment, it is mainly a syntactic sugar when deployed on a CPU (as it doesn't seem to be hooked up to MKL); however, when running code on a GPU, it seamlessly integrates with CUDA, making use of the cuBLAS's native batched operations.","category":"page"},{"location":"pages/batched_operations/","page":"Batched Operations","title":"Batched Operations","text":"Though the most common use cases are covered by NNlib many aren't and it doesn't take long to encounter them. For now, this package implements some of the common batched operations encountered when working with IMU data that don't feature in NNlib; though only to the extent of being a syntactic sugar for operations on CPUs.","category":"page"},{"location":"pages/batched_operations/","page":"Batched Operations","title":"Batched Operations","text":"danger: TODO\nOnce the imu.dev project reaches certain level of maturity we will aim to implement the most relevant batched operations on GPUs (by hooking to cuBLAS, which won't be difficult as CUDA.jl already does the heavy lifting), but for the time being, no concrete plans are made as to the exact date when that would happen.","category":"page"},{"location":"pages/batched_operations/#Matrix-vector-multiplication","page":"Batched Operations","title":"Matrix-vector multiplication","text":"","category":"section"},{"location":"pages/batched_operations/","page":"Batched Operations","title":"Batched Operations","text":"batched_matvecmul","category":"page"},{"location":"pages/batched_operations/#IMUDevNNLib.batched_matvecmul","page":"Batched Operations","title":"IMUDevNNLib.batched_matvecmul","text":"alt_batched_mul(A::Abstract3Tensor, B::AbstractMatrix)\n\nNNlib's batched_mul may not behave as expected when one of the arguments is a matrix. NNlib assumes that the matrix B must be broadcasted over each batch, however, what might instead be desired is to treat B as a batch of vectors for which a batch matrix-vector multiplication is desired.\n\n\n\n\n\n","category":"function"},{"location":"pages/batched_operations/#Matrix-inverse","page":"Batched Operations","title":"Matrix inverse","text":"","category":"section"},{"location":"pages/batched_operations/","page":"Batched Operations","title":"Batched Operations","text":"batched_rinv\nbatched_rinvsolve\nbatched_rinvsolve!","category":"page"},{"location":"pages/batched_operations/#IMUDevNNLib.batched_rinv","page":"Batched Operations","title":"IMUDevNNLib.batched_rinv","text":"batched_rinv(A::Abstract3Tensor)\n\nCompute the inverse of each matrix in the batch A. Assumes that the last dimension is the batch dimension.\n\n\n\n\n\n","category":"function"},{"location":"pages/batched_operations/#IMUDevNNLib.batched_rinvsolve","page":"Batched Operations","title":"IMUDevNNLib.batched_rinvsolve","text":"batched_rinvsolve(A::Abstract3Tensor, B::Abstract3Tensor)\n\nCompute the solution to the equation A⁽ⁱ⁾X = B⁽ⁱ⁾ for each matrix pair (A⁽ⁱ⁾, B⁽ⁱ⁾) in the batch. Assumes that the last dimension is the batch dimension.\n\n\n\n\n\n","category":"function"},{"location":"pages/batched_operations/#IMUDevNNLib.batched_rinvsolve!","page":"Batched Operations","title":"IMUDevNNLib.batched_rinvsolve!","text":"batched_rinvsolve!(out::Abstract3Tensor, A::Abstract3Tensor, B::Abstract3Tensor)\n\nCompute the solution to the equation A⁽ⁱ⁾X = B⁽ⁱ⁾ for each matrix pair (A⁽ⁱ⁾, B⁽ⁱ⁾) in the batch and save the results to out. Assumes that the last dimension is the batch dimension.\n\n\n\n\n\n","category":"function"},{"location":"pages/temporal_data/#Temporal-Data","page":"Temporal Data","title":"Temporal Data","text":"","category":"section"},{"location":"pages/temporal_data/","page":"Temporal Data","title":"Temporal Data","text":"Passing a time-series data through a Neural Network often requires a choice of an architecture that falls under the category of the so-called Recurrent Neural Networks (RNNs). Flux package (that the project imu.dev predominantly relies upon for the task of training Neural Nets) requires these data to adhere to a certain format. For this purpose we define a TemporalData struct to provide a unified way of handling training/validation/testing data to be passed through RNNs.","category":"page"},{"location":"pages/temporal_data/","page":"Temporal Data","title":"Temporal Data","text":"TemporalData","category":"page"},{"location":"pages/temporal_data/#IMUDevNNLib.TemporalData","page":"Temporal Data","title":"IMUDevNNLib.TemporalData","text":"TemporalData(xx::Vector{S}, yy::Vector{T}, x₀::S, y₀::T)\n\nA type for temporal data, i.e. data that are indexed by time. Conceptually, xx and yy are \"inputs\" and \"targets\" respectively. Both xx and yy are vectors of arrays, where each array corresponds to a timepoint. Optionally, x₀ and y₀ can be provided, which correspond to the initial state and the initial observation (the latter is usually ignored).\n\ntip: Tip\nSometimes only one pair (x₀, xx) or (y₀, yy) is needed or available (for instance, in production during forecasting). In such cases, the other pair is usually left empty.\n\nConstructors\n\ntemporal_data([T::DataType];\n              xx::Union{<:AbstractArray,Missing}=missing,\n              yy::Union{<:AbstractArray,Missing}=missing,\n              x₀::Union{<:AbstractArray,Missing}=missing,\n              y₀::Union{<:AbstractArray,Missing}=missing,\n              skipfirst=false)\n\ntemporal_data([T::DataType], xx::AbstractArray, yy::AbstractArray;\n              x₀::Union{<:AbstractArray,Missing}=missing,\n              y₀::Union{<:AbstractArray,Missing}=missing,\n              skipfirst=false)\n\nConvenience constructor for TemporalData which accepts the data stored in single arrays (as opposed to vector of arrays). It expects that the last dimension of xx and yy correspond to the time dimension, whereas the penultimate dimension corresponds to the batch dimension. If T is provided, it will be used to convert the data to the specified type. If skipfirst is true, the first observation will be skipped for saving into internal xx and yy and stored separately as x₀ and y₀ (it is convenient, as it is not uncommon to treat the \"zero'th\" observation different from the rest). x₀ and y₀ may also be provided explicitly, in which case skipfirst will still skip the first observation, but it will be the user-provided x₀ and/or y₀ that will take the priority of being stored in the internal state of TemporalData as the inital states. At least one of xx or yy must be provided. If the other is left out, an empty placeholder will be created in its place.\n\n\n\n\n\n","category":"type"},{"location":"pages/temporal_data/#Data-Loader","page":"Temporal Data","title":"Data Loader","text":"","category":"section"},{"location":"pages/temporal_data/","page":"Temporal Data","title":"Temporal Data","text":"The TemporalData implements the interface required by DataLoader, which means it can be passed to it directly","category":"page"},{"location":"pages/temporal_data/","page":"Temporal Data","title":"Temporal Data","text":"IMUDevNNLib.MLUtils.numobs\nIMUDevNNLib.MLUtils.getobs","category":"page"},{"location":"pages/temporal_data/#MLUtils.numobs","page":"Temporal Data","title":"MLUtils.numobs","text":"MLUtils.numobs(d::TemporalData)\n\nFor temporal data, the number of observations is synonymous with the batch size. Batch size is going to be the last dimension of every array corresponding to any timepoint.\n\n\n\n\n\n","category":"function"},{"location":"pages/temporal_data/#MLUtils.getobs","page":"Temporal Data","title":"MLUtils.getobs","text":"MLUtils.getobs(d::TemporalData, i)\n\nReturn the entire time series for the i-th observation (if i is a vector or a range it will return a vector of time series for the correspoding batch.)\n\n\n\n\n\n","category":"function"},{"location":"pages/temporal_data/#Example","page":"Temporal Data","title":"Example","text":"","category":"section"},{"location":"pages/temporal_data/","page":"Temporal Data","title":"Temporal Data","text":"data = ...\ntd = temporal_data(Float32,\n                   data.train.xx,\n                   data.train.yy; skipfirst=true)\n\nloader = Flux.DataLoader(td; batchsize=20, shuffle=true)","category":"page"},{"location":"pages/temporal_data/#Utility-functions","page":"Temporal Data","title":"Utility functions","text":"","category":"section"},{"location":"pages/temporal_data/","page":"Temporal Data","title":"Temporal Data","text":"Utility functions include","category":"page"},{"location":"pages/temporal_data/","page":"Temporal Data","title":"Temporal Data","text":"num_samples\nnum_timepoints\nstate_dim\nobs_dim\nBase.size(td::TemporalData, of_what::Symbol; kwargs...)","category":"page"},{"location":"pages/temporal_data/#IMUDevNNLib.num_samples","page":"Temporal Data","title":"IMUDevNNLib.num_samples","text":"num_samples(td::TemporalData)\n\nThe number of availble samples in the temporal data (i.e. the maximal batch size).\n\n\n\n\n\n","category":"function"},{"location":"pages/temporal_data/#IMUDevNNLib.num_timepoints","page":"Temporal Data","title":"IMUDevNNLib.num_timepoints","text":"num_timepoints(td::TemporalData)\n\nThe number of timepoints in the temporal data.\n\n\n\n\n\n","category":"function"},{"location":"pages/temporal_data/#IMUDevNNLib.state_dim","page":"Temporal Data","title":"IMUDevNNLib.state_dim","text":"state_dim(td::TemporalData)\n\nReturn the dimension of the state space.\n\nnote: Note\nThe state dimension is known only if either the xx or x₀ are available. If both are missing, an error will be thrown.\n\n\n\n\n\n","category":"function"},{"location":"pages/temporal_data/#IMUDevNNLib.obs_dim","page":"Temporal Data","title":"IMUDevNNLib.obs_dim","text":"obs_dim(td::TemporalData)\n\nReturn the dimension of the observation space.\n\nnote: Note\nThe observation dimension is known only if either the yy or y₀ are available. If both are missing, an error will be thrown.\n\n\n\n\n\n","category":"function"},{"location":"pages/temporal_data/#Base.size-Tuple{TemporalData, Symbol}","page":"Temporal Data","title":"Base.size","text":"Base.size(td::TemporalData, of_what::Symbol; kwargs...)\n\nReturn the size of the output container for the given TemporalData object. This can be either:\n\nthe size of the state (if of_what is :state or :xx)\nthe size of the observation (if of_what is :obs, :observation or :yy)\n\nNote that the output container is assumed to be an N-tensor (N > 2) where the last two dimensions correspond to the batch and time dimensions respectively; and in particular, the time dimension includes the initial state!\n\n\n\n\n\n","category":"method"},{"location":"pages/temporal_data/#BatchedTemporalContainer","page":"Temporal Data","title":"BatchedTemporalContainer","text":"","category":"section"},{"location":"pages/temporal_data/","page":"Temporal Data","title":"Temporal Data","text":"Even though TemporalData is the preferred format for working with RNNs, in the end, after we've run our forecasting algorithm we often want to come back to the usual format of one big N+2 dimensional matrix (N > 0), where N is the dimension of the state (usually 1 as we work with vectors) and where the last two dimensions are the batch (or samples) and time dimensions respectively. For this reason we define a BatchedTemporalContainer that facilitates easy writing of such data already at thetime of running our forecasting/testing algorithms.","category":"page"},{"location":"pages/temporal_data/","page":"Temporal Data","title":"Temporal Data","text":"BatchedTemporalContainer","category":"page"},{"location":"pages/temporal_data/#IMUDevNNLib.BatchedTemporalContainer","page":"Temporal Data","title":"IMUDevNNLib.BatchedTemporalContainer","text":"BatchedTemporalContainer(T::DataType,\n                         size::NTuple{N,Int},\n                         batchsize::Int) where {N}\n\nA container that is used to write the results of operations performed on a TemporalData object. Internally, it is an N-tensor (N > 2) where the last two dimensions correspond to the batch and time dimensions respectively. Double indexing into this object via [i, t] returns the (N-2)-dimensional array corresponding to the t-th timepoint of the i-th batch. Single indexing [i] returns the entire time series of the i-th batch.\n\n\n\n\n\n","category":"type"},{"location":"pages/temporal_data/","page":"Temporal Data","title":"Temporal Data","text":"The container can be allocated directly from the TemporalData object by calling:","category":"page"},{"location":"pages/temporal_data/","page":"Temporal Data","title":"Temporal Data","text":"outputcontainer","category":"page"},{"location":"pages/temporal_data/#IMUDevNNLib.outputcontainer","page":"Temporal Data","title":"IMUDevNNLib.outputcontainer","text":"outputcontainer(td::TemporalData, for_what::Symbol; batchsize, kwargs...)\n\nCreate an output container for the given TemporalData object into which the output of smoothing can be conveniently saved in a batched manner. See BatchedTemporalContainer for more details. The for_what argument can be either :state or :obs (or any of their synonyms) to specify whether the output will be saved to xx or yy-sized container. The batchsize must correspond to the batch size at which the smoothing (or any other operation) is performed, so that indexing into the output container can be properly sized. obs_size or state_size can be specified to override the size of the output container. If not provided, the size will be inferred from the TemporalData (if possible).\n\nimportant: Important\nIf td splits the initial state from the internal containers xx and yy, the output container will be enriched with the additional space to hold the initial state.\n\n\n\n\n\n","category":"function"},{"location":"pages/temporal_data/","page":"Temporal Data","title":"Temporal Data","text":"And the data can be retrieved with:","category":"page"},{"location":"pages/temporal_data/","page":"Temporal Data","title":"Temporal Data","text":"getdata","category":"page"},{"location":"pages/temporal_data/#IMUDevNNLib.getdata","page":"Temporal Data","title":"IMUDevNNLib.getdata","text":"getdata(c::BatchedTemporalContainer)\n\nReturn the underlying data of the container.\n\n\n\n\n\n","category":"function"},{"location":"pages/temporal_data/#Example-2","page":"Temporal Data","title":"Example","text":"","category":"section"},{"location":"pages/temporal_data/","page":"Temporal Data","title":"Temporal Data","text":"Here is an example of how to use it:","category":"page"},{"location":"pages/temporal_data/","page":"Temporal Data","title":"Temporal Data","text":"model = ...\nfunction smooth(loader::Flux.DataLoade{<:TemporalData})\n    out = out_container(loader.data, :xx; batchsize=loader.batchsize)\n\n    for (i, (x₀, _, _, yy)) in enumerate(loader)\n        Flux.reset!(model)\n        init!(model, x₀)\n        # batch `i` timepoint `1`\n        out[i, 1] .= x₀\n        for (t, y) in enumerate(yy)\n            x̂ₜ = model(y)\n            # batch `i` timepoint `t+1`\n            out[i, t + 1] = x̂ₜ\n        end\n    end\n\n    return getdata(out)\nend","category":"page"}]
}
