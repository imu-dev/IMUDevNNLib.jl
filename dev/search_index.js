var documenterSearchIndex = {"docs":
[{"location":"pages/data_transformations/#Data-transformations","page":"Transformations","title":"Data transformations","text":"","category":"section"},{"location":"pages/data_transformations/","page":"Transformations","title":"Transformations","text":"Data transformation are very commonly employed in Machine Learning as a way to augment the training data.","category":"page"},{"location":"pages/data_transformations/","page":"Transformations","title":"Transformations","text":"DataTransformation","category":"page"},{"location":"pages/data_transformations/#IMUDevNNLib.DataTransformation","page":"Transformations","title":"IMUDevNNLib.DataTransformation","text":"abstract type DataTransformation\n\nParent to all preprocessing data transformations\n\nCallable functions\n\n(transf::DataTransformation)([rng::Random.AbstractRNG], data::AbstractArray...)\n\nApply transformation transf to the data.\n\n\n\n\n\n","category":"type"},{"location":"pages/data_transformations/#Implemented-data-transformations","page":"Transformations","title":"Implemented data transformations","text":"","category":"section"},{"location":"pages/data_transformations/","page":"Transformations","title":"Transformations","text":"IdentityTransformation\nRandomPlanarRotation\nRandomShift","category":"page"},{"location":"pages/data_transformations/#IMUDevNNLib.IdentityTransformation","page":"Transformations","title":"IMUDevNNLib.IdentityTransformation","text":"struct IdentityTransformation <: DataTransformation\n\nIdentity transformation. Does nothing to the data that's passed through it.\n\nCallable functions\n\n(::IdentityTransformation)([::Random.AbstractRNG],\n                           ::DataTransformation,\n                           data::AbstractArray...)\n\nPass data through the transformation. Nothing is done to it.\n\n\n\n\n\n","category":"type"},{"location":"pages/data_transformations/#IMUDevNNLib.RandomPlanarRotation","page":"Transformations","title":"IMUDevNNLib.RandomPlanarRotation","text":"struct RandomPlanarRotation{T} <: DataTransformation\n\nRandom rotation of the data in the plane spanned by indices. The angle is chosen uniformly from the interval [-max_angle, max_angle].\n\nCallable functions\n\n(transf::RandomPlanarRotation)([rng::Random.AbstractRNG],\n                               ::SingleObsTimeseriesLayout,\n                               data::AbstractMatrix...)\n\nEach matrix data is rotated by the same angle.\n\n(transf::RandomPlanarRotation)(rng::Random.AbstractRNG,\n                               ::StackedArrayLayout,\n                               data::Abstract3Tensor...)\n\nEach sample in data is rotated by a different angle, note however, that each tensor data is rotated by the same sequence of angles. In other words, sample i from each tensor data is rotated by the same angle and sample j from each tensor data is rotated by the same angle, but angles for samples i and j (with i≠j) are (in general) different from one another.\n\n\n\n\n\n","category":"type"},{"location":"pages/data_transformations/#IMUDevNNLib.RandomShift","page":"Transformations","title":"IMUDevNNLib.RandomShift","text":"struct RandomShift <: DataTransformation\n\nShift the data in the time dimension by a random amount chosen uniformly from the interval (-max_shift, max_shift).\n\nConstructor\n\nRandomShift(max_shift::Int)\n\nCallable functions\n\n(transf::RandomShift)(rng::Random.AbstractRNG,\n                      ::StackedArrayLayout,\n                      data::AbstractArray...)\n\nIt assumes that the data passed through it is a time series with the time dimension encompassing segment:\n\nleft_padding | window | right_padding\n\nwhere left_padding and right_padding are the same and equal to max_shift.\n\n\n\n\n\n","category":"type"},{"location":"pages/data_transformations/","page":"Transformations","title":"Transformations","text":"RandomPlanarRotation will call function plane_rotation under the hood:","category":"page"},{"location":"pages/data_transformations/","page":"Transformations","title":"Transformations","text":"plane_rotation","category":"page"},{"location":"pages/data_transformations/#IMUDevNNLib.plane_rotation","page":"Transformations","title":"IMUDevNNLib.plane_rotation","text":"plane_rotation(data::AbstractMatrix, angle; plane_indices=1:2)\n\nRotate the data in the plane spanned by indices plane_indices by angle. The data are assumed to be given in a matrix form, with:\n\nfirst dimension indexing through the state coordinates, and\nthe second dimension indexing through the time points\n\nplane_rotation(data::Abstract3Tensor, angles::AbstractVector; plane_indices=1:2)\n\nRotate the data in the plane spanned by indices plane_indices by angles. The data are assumed to be given in a 3-tensor form, with:\n\nfirst dimension indexing through the state coordinates,\nthe second dimension indexing through the samples, and\nthe third dimension indexing through the time points\n\n\n\n\n\n","category":"function"},{"location":"pages/other/#Other","page":"Other","title":"Other","text":"","category":"section"},{"location":"pages/other/","page":"Other","title":"Other","text":"Some additional tools include:","category":"page"},{"location":"pages/other/","page":"Other","title":"Other","text":"skipfirstobs\nselectfirstobs\npeelfirstobs\nselectalonglastdim\nmergealonglastdim\nnnflatten","category":"page"},{"location":"pages/other/#IMUDevNNLib.skipfirstobs","page":"Other","title":"IMUDevNNLib.skipfirstobs","text":"skipfirstobs(x::AbstractArray; timedim=ndims(x)-1)\n\nGiven an array x representing a time series, with the timedim dimension corresponding to time, return a new array with the first observation removed.\n\n\n\n\n\n","category":"function"},{"location":"pages/other/#IMUDevNNLib.selectfirstobs","page":"Other","title":"IMUDevNNLib.selectfirstobs","text":"selectfirstobs(x::AbstractArray; timedim=ndims(x)-1)\n\nGiven an array x representing a time series, with the timedim dimension corresponding to time, return a new array with only the first observation.\n\n\n\n\n\n","category":"function"},{"location":"pages/other/#IMUDevNNLib.peelfirstobs","page":"Other","title":"IMUDevNNLib.peelfirstobs","text":"peelfirstobs(x::AbstractArray; timedim=ndims(x)-1)\n\nGiven an array x representing a time series, with the timedim dimension corresponding to time, return two array views:\n\nview into the first observation,\nview into the remaining observations.\n\n\n\n\n\n","category":"function"},{"location":"pages/other/#IMUDevNNLib.selectalonglastdim","page":"Other","title":"IMUDevNNLib.selectalonglastdim","text":"selectalonglastdim(m::AbstractArray, i)\n\nSelect subview of the array m with index i accessed along the last dimension of this array.\n\n\n\n\n\n","category":"function"},{"location":"pages/other/#IMUDevNNLib.mergealonglastdim","page":"Other","title":"IMUDevNNLib.mergealonglastdim","text":"mergealonglastdim(data::Vector{<:AbstractArray})\n\nMerge a collection of arrays along their last dimension. The arrays must agree in all dimensions except the last one.\n\ntip: Tip\nyes, cat(data...; dims=ndims(first(data))) will work, but for large arrays it will be very, very inefficient, in which case you're better off using mergealonglastdim.\n\n\n\n\n\n","category":"function"},{"location":"pages/other/#IMUDevNNLib.nnflatten","page":"Other","title":"IMUDevNNLib.nnflatten","text":"nnflatten(x::AbstractArray{<:Any,N}) where {N}\n\nA common flattening scheme encountered in machine learning libraries: flatten the array x into a 2D array by squashing all dimensions except the last one (i.e. except the batch dimension).\n\n\n\n\n\n","category":"function"},{"location":"pages/writing_output/#Writing-output","page":"Writing output","title":"Writing output","text":"","category":"section"},{"location":"pages/writing_output/","page":"Writing output","title":"Writing output","text":"Once the training and testing is done and we have a model we wish to use in production we often need to save the results. The prediction happening in production stage may still happen in batches, but we often wish to save the data in a common StackedArrayLayout. To this end, we can make use of a utility struct BatchDelimitedArray to save to and read from using iteration that iterates over batches:","category":"page"},{"location":"pages/writing_output/","page":"Writing output","title":"Writing output","text":"BatchDelimitedArray","category":"page"},{"location":"pages/writing_output/#IMUDevNNLib.BatchDelimitedArray","page":"Writing output","title":"IMUDevNNLib.BatchDelimitedArray","text":"struct BatchDelimitedArray{T, S<:AbstractArray} <: AbstractArray{T, 1}\n\nAn array data that is split into blocks of batches of size batchsize each (with the last batch possibly shrunk to fit the data's dimensions). Indexing effectively works like indexing over a Vector of subarrays, where each subarray corresponds to a batch.\n\nConstructors\n\nbatchdelimitedarray(K::DataType, size::NTuple{<:Any,Int}, batchsize::Int)\n\nCreate a BatchDelimitedArray with underlying data of size and eltype K.\n\nbatchdelimitedarray(data::AbstractArray, batchsize::Int)\n\nSame as the default BatchDelimitedArray's constructor.\n\ntip: Tip\nUsing a constructor that expects data::AbstractArray can be handy if you wish to use a Mmap-ed array.\n\n\n\n\n\n","category":"type"},{"location":"pages/writing_output/","page":"Writing output","title":"Writing output","text":"Rather than accessing data through:","category":"page"},{"location":"pages/writing_output/","page":"Writing output","title":"Writing output","text":"a::BatchDelimitedArray\na.data","category":"page"},{"location":"pages/writing_output/","page":"Writing output","title":"Writing output","text":"it is recommended to use getdata function instead:","category":"page"},{"location":"pages/writing_output/","page":"Writing output","title":"Writing output","text":"getdata","category":"page"},{"location":"pages/writing_output/#IMUDevNNLib.getdata","page":"Writing output","title":"IMUDevNNLib.getdata","text":"getdata(a::BatchDelimitedArray)\n\nReturn the underlying data of the container.\n\n\n\n\n\n","category":"function"},{"location":"pages/timeseries_iteration/#Iteration-over-timeseries-data","page":"Iteration","title":"Iteration over timeseries data","text":"","category":"section"},{"location":"pages/timeseries_iteration/","page":"Iteration","title":"Iteration","text":"In order to pass timeseries data through a recurrent neural networks we must iterate over timepoints and pass them one by one. Further complication may arise if the features timeseries and the labels timeseries are not to be simply zipped together in a 1-to-1 manner. (an example would be: 1 observation (label: position) per 30 collected data points (feature: acceleration)). To this end we introduce an interface for TimeseriesIterationPolicy.","category":"page"},{"location":"pages/timeseries_iteration/#Interface-for-iteration-policy","page":"Iteration","title":"Interface for iteration policy","text":"","category":"section"},{"location":"pages/timeseries_iteration/","page":"Iteration","title":"Iteration","text":"takexx\ntakeyy\nnum_timepoints","category":"page"},{"location":"pages/timeseries_iteration/#IMUDevNNLib.takexx","page":"Iteration","title":"IMUDevNNLib.takexx","text":"takexx(policy, iter_state::Int)\n\nReturn a boolean for whether to take the next xx at iteration iter_state.\n\n\n\n\n\n","category":"function"},{"location":"pages/timeseries_iteration/#IMUDevNNLib.takeyy","page":"Iteration","title":"IMUDevNNLib.takeyy","text":"takeyy(policy, iter_state::Int)\n\nReturn a boolean for whether to take the next yy at iteration iter_state.\n\n\n\n\n\n","category":"function"},{"location":"pages/timeseries_iteration/#IMUDevNNLib.num_timepoints","page":"Iteration","title":"IMUDevNNLib.num_timepoints","text":"num_timepoints(iter_policy, d::DataLayout, xx, yy)\n\nCompute the number of timepoints for a given iteration policy p, data layout d and containers xx and yy.\n\n\n\n\n\n","category":"function"},{"location":"pages/timeseries_iteration/","page":"Iteration","title":"Iteration","text":"note: Notation\nfeatures (or input) and labels come from the machine learning terminology, whereas xx and yy are used in State Space Models. The mapping between the two can be unintuitive. For instace, consider the following example from IMU data:todo: Example\nWe observe acceleration and angular velocity to predict position.From the machine learning perspective we have:features: the observations, i.e. acceleration and angular velocity\nlabels: the things we wish to predict i.e. position On the other hand, from the perspective of state space modelling:xx: the \"underlying state\", i.e. position\nyy: the observations, i.e. acceleration and angular velocitySo, technically, the mapping between two should befeatures ⟷ yy\nlabels ⟷ xxHowever, TimeseriesIterationPolicy does not enforce this mapping and the user is free to pass whatever as xx or yy. They just need to make sure that the policy they apply to will act on the appropriate containers that they've passed.In fact, it is not uncommon to, rather confusingly use the notation x and y (or X and Y) also in machine learning and use a mapping:features ⟷ x\nlabels ⟷ yWe do not commit to any particular convention. In any example the adopted convention should follow easily from its context.","category":"page"},{"location":"pages/timeseries_iteration/#Implemented-policies","page":"Iteration","title":"Implemented policies","text":"","category":"section"},{"location":"pages/timeseries_iteration/","page":"Iteration","title":"Iteration","text":"ZipIterPolicy\nTakeX0IterPolicy\nTakeX0NoY0Policy","category":"page"},{"location":"pages/timeseries_iteration/#IMUDevNNLib.ZipIterPolicy","page":"Iteration","title":"IMUDevNNLib.ZipIterPolicy","text":"struct ZipIterPolicy\n\nA default iteration policy for TimeseriesIterator that zips all xx and yy in a one-to-one fashion.\n\n\n\n\n\n","category":"type"},{"location":"pages/timeseries_iteration/#IMUDevNNLib.TakeX0IterPolicy","page":"Iteration","title":"IMUDevNNLib.TakeX0IterPolicy","text":"struct TakeX0IterPolicy\n\nAn iteration policy for TimeseriesIterator that takes the first underlying state x₀, but discards all the rest and takes all states in yy.\n\n\n\n\n\n","category":"type"},{"location":"pages/timeseries_iteration/#IMUDevNNLib.TakeX0NoY0Policy","page":"Iteration","title":"IMUDevNNLib.TakeX0NoY0Policy","text":"struct TakeX0NoY0Policy\n\nAn iteration policy for TimeseriesIterator that takes the first underlying state x₀, but discards all the rest, as well as assumes that yy has no observation y₀ that would correspond to x₀.\n\n\n\n\n\n","category":"type"},{"location":"pages/timeseries_iteration/#Iteration","page":"Iteration","title":"Iteration","text":"","category":"section"},{"location":"pages/timeseries_iteration/","page":"Iteration","title":"Iteration","text":"To iterate over two containers according to some policy use TimeseriesIterator:","category":"page"},{"location":"pages/timeseries_iteration/","page":"Iteration","title":"Iteration","text":"TimeseriesIterator","category":"page"},{"location":"pages/timeseries_iteration/#IMUDevNNLib.TimeseriesIterator","page":"Iteration","title":"IMUDevNNLib.TimeseriesIterator","text":"struct TimeseriesIterator{FT<:Base.Iterators.Stateful, LT<:Base.Iterators.Stateful, P}\n\nA joint iterator over two iterables xx and yy that conceptually correspond to \"underlying state\" and \"observations\". Use timeseriesiterator to construct this struct.\n\nConstructors\n\ntimeseriesiterator(xx::Vector{<:AbstractArray},\n                   yy::Vector{<:AbstractArray},\n                   policy;\n                   num_timepoints::Int=num_timepoints(policy,\n                                                      TimeseriesLayout(),\n                                                      xx,\n                                                      yy))\n\nA recommended constructor for TimeseriesIterator. num_timepoints is the total number of timepoints in a timeseries. policy defines the way in which joint iteration over xx and yy should be carried out.\n\nnote: Note\nUsually num_timepoints(TimeseriesLayout(), xx) == num_timepoints(TimeseriesLayout(), yy) == num_timepoints, but in general this need not be the case if a custom iteration policy is defined.\n\n\n\n\n\n","category":"type"},{"location":"pages/timeseries_iteration/","page":"Iteration","title":"Iteration","text":"The following utility function is implemented for the TimeseriesIterator:","category":"page"},{"location":"pages/timeseries_iteration/","page":"Iteration","title":"Iteration","text":"Iterators.reset!","category":"page"},{"location":"pages/timeseries_iteration/#Base.Iterators.reset!","page":"Iteration","title":"Base.Iterators.reset!","text":"Iterators.reset!(i::TimeseriesIterator)\n\nReset the internal iterators to a starting position.\n\n\n\n\n\n","category":"function"},{"location":"pages/timeseries_iteration/#Example","page":"Iteration","title":"Example","text":"","category":"section"},{"location":"pages/timeseries_iteration/","page":"Iteration","title":"Iteration","text":"A very common workflow when working with Recurrent Neural Networks is demonstrated with the following pseudo-code:","category":"page"},{"location":"pages/timeseries_iteration/","page":"Iteration","title":"Iteration","text":"data_loader = ...\npreprocess!(...) = ...\nmodel = ...\ninit_model! = ...\nloss = ...\ndo_something_with_loss = ...\n\nfor (features, labels) in data_loader\n    preprocess!(features, labels)\n\n    features = reshape(features, StackedArrayLayout() => TimeseriesLayout())\n    labels = reshape(input, StackedArrayLayout() => TimeseriesLayout())\n\n    it = timeseriesiterator(features, labels, ZipIterPolicy())\n\n    (x₀, y₀), it = Iterators.peel(it)\n    init_model!(model, x₀, y₀)\n\n    for (x, y) in it\n        y° = model(x)\n        l = loss(y, y°)\n        do_something_with_loss(...)\n    end\nend","category":"page"},{"location":"pages/data_layouts/#Data-Layouts","page":"Data Layouts","title":"Data Layouts","text":"","category":"section"},{"location":"pages/data_layouts/","page":"Data Layouts","title":"Data Layouts","text":"DataLayouts define conventions for storing data.","category":"page"},{"location":"pages/data_layouts/","page":"Data Layouts","title":"Data Layouts","text":"note: Note\nIn imu.dev we are mostly interested in IMU data and these almost exclisively take the form of timeseries; however, in principle, any type of data can be represented with a suitable subtype of DataLayout.","category":"page"},{"location":"pages/data_layouts/","page":"Data Layouts","title":"Data Layouts","text":"DataLayout","category":"page"},{"location":"pages/data_layouts/#IMUDevNNLib.DataLayout","page":"Data Layouts","title":"IMUDevNNLib.DataLayout","text":"abstract type DataLayout\n\nParent to all defined data layouts. First and foremost, DataLayouts are merely conventions for consistently arranging data for analysis. From a more practical standpoint however, there are a couple of Base.reshape implementations that allow for transforming between different layouts. Additionally, there are also some utility functions.\n\n\n\n\n\n","category":"type"},{"location":"pages/data_layouts/#Implemented-layouts","page":"Data Layouts","title":"Implemented layouts","text":"","category":"section"},{"location":"pages/data_layouts/","page":"Data Layouts","title":"Data Layouts","text":"SingleTimeseriesLayout\nTimeseriesLayout\nSingleObsTimeseriesLayout\nStackedArrayLayout","category":"page"},{"location":"pages/data_layouts/#IMUDevNNLib.SingleTimeseriesLayout","page":"Data Layouts","title":"IMUDevNNLib.SingleTimeseriesLayout","text":"struct SingleTimeseriesLayout <: DataLayout\n\nData stored in SingleTimeseriesLayout comprises of a single long timeseries stored in a single array. It's a (N-1)-dimensional array with\n\nthe first (N-2)-dimensions corresponding to the state space\nthe last (N-1)-th dimension corresponding to time\n\nnote: Note\nThere is only one sample, so one dimension that's usually reserved for samples (i.e. N-th dimension) is dropped.\n\ntip: Example\nConsider a single recording from an IMU device that's been recording for one day @1Hz. The data extracted from this device in a SingleTimeseriesLayout would be represented as a Matrix with dimensions 3×86_400, with each column representing a single observation of the 3d-acceleration.\n\n\n\n\n\n","category":"type"},{"location":"pages/data_layouts/#IMUDevNNLib.TimeseriesLayout","page":"Data Layouts","title":"IMUDevNNLib.TimeseriesLayout","text":"struct TimeseriesLayout <: DataLayout\n\nData stored in TimeseriesLayout comprises of a collection (usually a vector) of arrays, which conceptually represents a timeseries of observations for multiple samples. Each element of the collection is an (N-1)-dimensional array with:\n\nthe first (N-2)-dimensions corresponding to the state space\nthe last (N-1)-th dimension corresponding to samples\n\nThe collection indexes over timepoints (which can be thought of as the N-th dimension).\n\ntip: Example\nConsider two recordings from two synchronized IMU devices that have been recording for one day @1Hz. The data extracted from these two devices in a TimeseriesLayout would be represented as a Vector{Matrix} with length 86_400, where each element of this vector would have dimensions 3×2 (i.e. it would be two vectors of 3d-accelerations horizontally concatenated together into a 3×2 Matrix).\n\n\n\n\n\n","category":"type"},{"location":"pages/data_layouts/#IMUDevNNLib.SingleObsTimeseriesLayout","page":"Data Layouts","title":"IMUDevNNLib.SingleObsTimeseriesLayout","text":"struct SingleObsTimeseriesLayout <: DataLayout\n\nData stored as SingleObsTimeseriesLayout is simply a single array element (conceptually an observation) from the collection that's stored in TimeseriesLayout.\n\n\n\n\n\n","category":"type"},{"location":"pages/data_layouts/#IMUDevNNLib.StackedArrayLayout","page":"Data Layouts","title":"IMUDevNNLib.StackedArrayLayout","text":"struct StackedArrayLayout <: DataLayout\n\nData stored in the StackedArrayLayout is an N-dimensional array with the last, N-th dimension indexing over samples.\n\nnote: Note\nFor a particular case of StackedArrayLayout intended to respresent time series data we follow the convention of using an N-dimensional array with:the first (N-2)-dimensions corresponding to the state space\nthe (N-1)-th dimension corresponding to time, and\nthe N-th dimension corresponding to samples.\n\n\n\n\n\n","category":"type"},{"location":"pages/data_layouts/#Utility-functions","page":"Data Layouts","title":"Utility functions","text":"","category":"section"},{"location":"pages/data_layouts/","page":"Data Layouts","title":"Data Layouts","text":"As DataLayouts impose some conventions about how the data are organized, knowing the type of DataLayout is sometimes already enough to extract useful information without needing to know any further specifics. We implement a couple of such utility functions:","category":"page"},{"location":"pages/data_layouts/","page":"Data Layouts","title":"Data Layouts","text":"state_dim\nnum_samples\nnum_timepoints(::TimeseriesLayout, data::Vector{<:AbstractArray})","category":"page"},{"location":"pages/data_layouts/#IMUDevNNLib.state_dim","page":"Data Layouts","title":"IMUDevNNLib.state_dim","text":"state_dim(::Union{TimeseriesLayout,SingleObsTimeseriesLayout,\n                  SingleTimeseriesLayout},\n          data::AbstractArray)\n          \nstate_dim(layout::TimeseriesLayout, data::Vector{<:AbstractArray})\n\nReturn the dimension of the state space of the time series data.\n\nnote: Note\nThe state space may in principle be represented by any AbstractArrays (i.e. not necessarily a Vector). Following the convention for Base.size the dimension is given as a tuple of integers.\n\n\n\n\n\n","category":"function"},{"location":"pages/data_layouts/#IMUDevNNLib.num_samples","page":"Data Layouts","title":"IMUDevNNLib.num_samples","text":"num_samples(layout::DataLayout, data::AbstractArray)\n\nnum_samples(layout::TimeseriesLayout, data::Vector{<:AbstractArray})\n\nnum_samples(layout::SingleTimeseriesLayout, data::AbstractArray)\n\nReturn the total number of samples in data.\n\n\n\n\n\n","category":"function"},{"location":"pages/data_layouts/#IMUDevNNLib.num_timepoints-Tuple{TimeseriesLayout, Vector{<:AbstractArray}}","page":"Data Layouts","title":"IMUDevNNLib.num_timepoints","text":"num_timepoints(layout::TimeseriesLayout, data::Vector{<:AbstractArray})\n\nnum_timepoints(layout::StackedArrayLayout, data::AbstractArray)\n\nnum_timepoints(layout::SingleTimeseriesLayout, data::AbstractArray)\n\nReturn the number of time points in the time series data.\n\n\n\n\n\n","category":"method"},{"location":"pages/data_layouts/","page":"Data Layouts","title":"Data Layouts","text":"Additionally, there are some further utility functions that make sense only under specific DataLayouts:","category":"page"},{"location":"pages/data_layouts/","page":"Data Layouts","title":"Data Layouts","text":"write_header!\nread_header","category":"page"},{"location":"pages/data_layouts/#IMUDevNNLib.write_header!","page":"Data Layouts","title":"IMUDevNNLib.write_header!","text":"write_header!(io::IOStream, ::StackedArrayLayout, dims)\n\nUtility function for writing the header of a binary file that stores data in StackedArrayLayout. dims is a tuple of integers representing the dimensions of the data.\n\n\n\n\n\n","category":"function"},{"location":"pages/data_layouts/#IMUDevNNLib.read_header","page":"Data Layouts","title":"IMUDevNNLib.read_header","text":"read_header(io::IOStream, ::StackedArrayLayout)\n\nUtility function for reading the header of a binary file that stores data in StackedArrayLayout.\n\n\n\n\n\n","category":"function"},{"location":"pages/data_layouts/","page":"Data Layouts","title":"Data Layouts","text":"Finally, we provide routines to convert between different layouts:","category":"page"},{"location":"pages/data_layouts/","page":"Data Layouts","title":"Data Layouts","text":"Base.reshape\ndimsofreshape","category":"page"},{"location":"pages/data_layouts/#Base.reshape","page":"Data Layouts","title":"Base.reshape","text":"Base.reshape(data::AbstractArray, from_to::Pair{LayoutA, LayoutB})\n\nTransform data stored in LayoutA() into a format following LayoutB().\n\n\n\n\n\n","category":"function"},{"location":"pages/data_layouts/#IMUDevNNLib.dimsofreshape","page":"Data Layouts","title":"IMUDevNNLib.dimsofreshape","text":"dimsofreshape(data::Vector{<:BatchDelimitedArray},\n              from_to::Pair{TimeseriesLayout,StackedArrayLayout})\n\nCompute the size of the Array that would be needed to reshape data stored in TimeseriesLayout() into a format following StackedArrayLayout().\n\ntip: Tip\nUsing this function, as opposed to calling Base.reshape might be handy if it's not possible to perform the reshaping in memory, and instead, an Mmap array needs to be constructed.\n\n\n\n\n\n","category":"function"},{"location":"#IMUDevNNLib.jl","page":"Home","title":"IMUDevNNLib.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Toolbox designed to support workflows involving Neural Networks, in particular, specializing to IMU data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Tip\nFor more general toolbox see NNlib","category":"page"},{"location":"pages/batched_operations/#Batched-Operations","page":"Batched Operations","title":"Batched Operations","text":"","category":"section"},{"location":"pages/batched_operations/","page":"Batched Operations","title":"Batched Operations","text":"NNlib implements a useful spectrum of operations designed to work with batches. At the moment, it is mainly a syntactic sugar when deployed on a CPU (as it doesn't seem to be hooked up to MKL); however, when running code on a GPU, it seamlessly integrates with CUDA, making use of the cuBLAS's native batched operations.","category":"page"},{"location":"pages/batched_operations/","page":"Batched Operations","title":"Batched Operations","text":"Though the most common use cases are covered by NNlib many aren't and it doesn't take long to encounter them. For now, this package implements some of the common batched operations encountered when working with IMU data that don't feature in NNlib; though only to the extent of being a syntactic sugar for operations on CPUs.","category":"page"},{"location":"pages/batched_operations/","page":"Batched Operations","title":"Batched Operations","text":"danger: TODO\nOnce the imu.dev project reaches certain level of maturity we will aim to implement the most relevant batched operations on GPUs (by hooking to cuBLAS, which won't be difficult as CUDA.jl already does the heavy lifting), but for the time being, no concrete plans are made as to the exact date when that would happen.","category":"page"},{"location":"pages/batched_operations/#Matrix-vector-multiplication","page":"Batched Operations","title":"Matrix-vector multiplication","text":"","category":"section"},{"location":"pages/batched_operations/","page":"Batched Operations","title":"Batched Operations","text":"batched_matvecmul","category":"page"},{"location":"pages/batched_operations/#IMUDevNNLib.batched_matvecmul","page":"Batched Operations","title":"IMUDevNNLib.batched_matvecmul","text":"batched_matvecmul(A::Abstract3Tensor, B::AbstractMatrix)\n\nNNlib's batched_mul may not behave as expected when one of the arguments is a matrix. NNlib assumes that the matrix B must be broadcasted over each batch, however, what might instead be desired is to treat B as a batch of vectors for which a batch matrix-vector multiplication is desired.\n\n\n\n\n\n","category":"function"},{"location":"pages/batched_operations/#Matrix-inverse","page":"Batched Operations","title":"Matrix inverse","text":"","category":"section"},{"location":"pages/batched_operations/","page":"Batched Operations","title":"Batched Operations","text":"batched_rinv\nbatched_rinvsolve\nbatched_rinvsolve!","category":"page"},{"location":"pages/batched_operations/#IMUDevNNLib.batched_rinv","page":"Batched Operations","title":"IMUDevNNLib.batched_rinv","text":"batched_rinv(A::Abstract3Tensor)\n\nCompute the inverse of each matrix in the batch A. Assumes that the last dimension is the batch dimension.\n\n\n\n\n\n","category":"function"},{"location":"pages/batched_operations/#IMUDevNNLib.batched_rinvsolve","page":"Batched Operations","title":"IMUDevNNLib.batched_rinvsolve","text":"batched_rinvsolve(A::Abstract3Tensor, B::Abstract3Tensor)\n\nCompute the solution to the equation A⁽ⁱ⁾X = B⁽ⁱ⁾ for each matrix pair (A⁽ⁱ⁾, B⁽ⁱ⁾) in the batch. Assumes that the last dimension is the batch dimension.\n\n\n\n\n\n","category":"function"},{"location":"pages/batched_operations/#IMUDevNNLib.batched_rinvsolve!","page":"Batched Operations","title":"IMUDevNNLib.batched_rinvsolve!","text":"batched_rinvsolve!(out::Abstract3Tensor, A::Abstract3Tensor, B::Abstract3Tensor)\n\nCompute the solution to the equation A⁽ⁱ⁾X = B⁽ⁱ⁾ for each matrix pair (A⁽ⁱ⁾, B⁽ⁱ⁾) in the batch and save the results to out. Assumes that the last dimension is the batch dimension.\n\n\n\n\n\n","category":"function"},{"location":"pages/data_arrangers/#Data-arrangers","page":"Arrangers","title":"Data arrangers","text":"","category":"section"},{"location":"pages/data_arrangers/","page":"Arrangers","title":"Arrangers","text":"Data arrangers are used to get from the point of having raw data to data that are split into something resembling samples.","category":"page"},{"location":"pages/data_arrangers/","page":"Arrangers","title":"Arrangers","text":"DataArranger","category":"page"},{"location":"pages/data_arrangers/#IMUDevNNLib.DataArranger","page":"Arrangers","title":"IMUDevNNLib.DataArranger","text":"abstract type DataArranger\n\nParent to all structs that slice and dice data for further analysis.\n\n\n\n\n\n","category":"type"},{"location":"pages/data_arrangers/#Implemented-arrangers","page":"Arrangers","title":"Implemented arrangers","text":"","category":"section"},{"location":"pages/data_arrangers/","page":"Arrangers","title":"Arrangers","text":"Currently only a single DataArranger is implemented: SlidingWindow. It's very commonly employed to chop down a long recording into many short chunks that can be subsequently passed to a Neural Network.","category":"page"},{"location":"pages/data_arrangers/","page":"Arrangers","title":"Arrangers","text":"SlidingWindow","category":"page"},{"location":"pages/data_arrangers/#IMUDevNNLib.SlidingWindow","page":"Arrangers","title":"IMUDevNNLib.SlidingWindow","text":"struct SlidingWindow{T} <: DataArranger\n\nA data arranger that's a simple sliding window. It will cut segments of data from the input array by sliding a window of a fixed size, moving it by stride timepoints at a time. The windows can be additionally padded with pad elements on both sides; note however, that this will be a squishy padding on the edges of the data, meaning that only the window will be restricted to the bounds of the original data, whereas the padding will be free to jump over to the opposite site of the window (in such a way that sum(pad) is unchanged) if it encounters an edge.\n\nConstructors\n\nslidingwindow(T::DataType=Float32;\n              stride::Int=10,\n              window::Int=200,\n              pad=(left=0, right=0))\n\nA recommended way to construct a SlidingWindow data arranger. The T will be used to specify the eltype of the arranged data.\n\nFunction calls\n\n(arranger::SlidingWindow)(io::IOStream,\n                          from_to::Pair{SingleTimeseriesLayout,\n                                        StackedArrayLayout},\n                          data::AbstractArray)\n\nArrange the data using the SlidingWindow and write it to the io stream.\n\ntip: Tip\nThis is intended for writing the data to a binary file for subsequent reading using Mmap.\n\n(arranger::SlidingWindow)(from_to::Pair{SingleTimeseriesLayout,\n                                        StackedArrayLayout},\n                          data::AbstractArray)\n\nArrange the data using the SlidingWindow arranger and return it as a new array.\n\n\n\n\n\n","category":"type"}]
}
